/** @file
 *
 *  A jQuery-UI / flot-based graphical timeline capable of presenting timeline
 *  data generated by connexions.
 *
 *  The target DOM element MAY contain a 'div.timeline-plot',
 *  'div.timeline-legend', and/or 'div.timeline-annotation'.  If it does not,
 *  these DOM elements will be added.
 */
/*jslint nomen:false, laxbreak:true, white:false, onevar:false, plusplus:false */
/*global jQuery:false, window:false */
(function($) {

function leftPad(val, fillChar, padLen)
{
    fillChar = fillChar || '0';
    padLen   = padLen   || 2;

    val = "" + val;
    return val.length < padLen ? fillChar + val : val;
}

var numericRe = /^[0-9]+(\.[0-9]*)?$/;
              //   year      month           day
var datePat   = '^([0-9]{4})(0[0-9]|1[0-2])?([0-2][0-9]|3[01])?'
              //   hour               minute       second
              + '([0-1][0-9]|2[0-3])?([0-5][0-9])?([0-5][0-9])?$';
var dateRe    = new RegExp(datePat);

$.widget('connexions.timeline', {
    version:    '0.0.1',
    options:    {
        // Defaults
        xDataHint:      null,   /* hour | day-of-week |
                                 *  day | week | month | year
                                 *  fmt:%date format% - also implies that the
                                 *                      x-values are
                                 *                      date/times.
                                 */
        xLegendHint:    null,   /* Primarily for asynchronously loaded data,
                                 * a hint about how to format legend values
                                 * (same values are xDataHint).
                                 */

        css:            null,   /* Additional CSS class(es) to apply to the
                                 * primary DOM element
                                 */
        annotation:     null,   // Any annotation to include for this timtline
        rawData:        null,   // Raw, connexions timeline data to present
        data:           [],     // Initial, empty data

        width:          null,   // The width of the timeline plot area
        height:         null,   // The height of the timeline plot area
        hwRatio:        9/16,   /* Ratio of height to width
                                 * (used if 'height' is not specified)
                                 */


        hideLegend:     false,  // Hide the legend?
        valueInLegend:  true,   /* Show the y hover value(s) in the series
                                 * legend (hideLegend should be true);
                                 */
        valueInTips:    false,  // Show the y hover value(s) in series graph
        replaceLegend:  false,  /* Should the data label completely replace
                                 * any existing legend text when the value
                                 * is being presented? [ false ];
                                 */
        createControls: false,  /* Should controls be created if not provided
                                 * in the markup? [ false ];
                                 */

        /* General Json-RPC information:
         *  {version:   Json-RPC version,
         *   target:    URL of the Json-RPC endpoint,
         *   transport: 'POST' | 'GET'
         *  }
         *
         * If not provided, 'version', 'target', and 'transport' are
         * initialized from:
         *      $.registry('api').jsonRpc
         *
         * which is initialized from
         *      application/configs/application.ini:api
         * via
         *      application/layout/header.phtml
         */
        jsonRpc:    null,
        rpcMethod:  'bookmark.getTimeline',
        rpcParams:  null,   /* Any RPC parameter required by 'rpcMethod:
                             *  {
                             *      'tags':     Context-restricting tags,
                             *      'group':    Timeline grouping indicator,
                             *  }
                             */

        /* Place a general limit on the maximum amount of data returned.
         * Too much and we'll kill the browser.
         */
        maxCount:   1000,

        // DataType value->label tables
        hours:      [ '12a',  '1a',  '2a',  '3a',  '4a',  '5a',
                       '6a',  '7a',  '8a',  '9a', '10a', '11a',
                      '12p',  '1p',  '2p',  '3p',  '4p',  '5p',
                       '6p',  '7p',  '8p',  '9p', '10p', '11p' ],
        months:     [ 'January',   'Febrary', 'March',    'April',
                      'May',       'June',    'July',     'August',
                      'September', 'October', 'November', 'December' ],
        days:       [ 'Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa' ],

        /* Timeline grouping indicator map to information about how to
         * format/present the x-axis tick labels as well as the legend.
         */
        grouping:   {
            // Straight Timelines
            'YM':   {
                group:          'Simple Timelines',
                name:           'Year, Month',
                xDataHint:      'fmt:%Y %b',
                replaceLegend:  true
            },
            'Y':    {
                group:          'Simple Timelines',
                name:           'Year',
                xDataHint:      'fmt:%Y',
                replaceLegend:  true
            },
            'M':    {
                group:          'Simple Timelines',
                name:           'Month',
                xDataHint:      'mon',
                replaceLegend:  true
            },
            'w':    {
                group:          'Simple Timelines',
                name:           'Week',
                xDataHint:      'week',
                replaceLegend:  true
            },
            'D':    {
                group:          'Simple Timelines',
                name:           'Day',
                xDataHint:      'day',
                replaceLegend:  true
            },
            'd':    {
                group:          'Simple Timelines',
                name:           'Day-of-week',
                xDataHint:      'day-of-week',
                replaceLegend:  true
            },
            'H':    {
                group:          'Simple Timelines',
                name:           'Hour',
                xDataHint:      'hour',
                replaceLegend:  true
            },

            // Series Timelines (by Year)
            'Y:M':  {
                group:          'Series (by Year)',
                name:           'Month',
                xDataHint:      'mon',
                xLegendHint:    'year',
                replaceLegend:  false
            },
            'Y:D':  {
                group:          'Series (by Year)',
                name:           'Day (of month)',
                xDataHint:      'day',
                xLegendHint:    'year',
                replaceLegend:  false
            },
            'Y:d':  {
                group:          'Series (by Year)',
                name:           'Day (of week)',
                xDataHint:      'day-of-week',
                xLegendHint:    'year',
                replaceLegend:  false
            },
            'Y:H':  {
                group:          'Hour',
                name:           'Month',
                xDataHint:      'hour',
                xLegendHint:    'year',
                replaceLegend:  false
            },

            // Series Timelines (by Month)
            'M:D':  {
                group:          'Series (by Month)',
                name:           'Day (of month)',
                xDataHint:      'day',
                xLegendHint:    'mon',
                replaceLegend:  false
            },
            'M:d':  {
                group:          'Series (by Month)',
                name:           'Day (of week)',
                xDataHint:      'day-of-week',
                xLegendHint:    'mon',
                replaceLegend:  false
            },
            'M:H':  {
                group:          'Series (by Month)',
                name:           'Hour',
                xDataHint:      'hour',
                xLegendHint:    'mon',
                replaceLegend:  false
            },

            // Series Timelines (by Week)
            'w:d':  {
                group:          'Series (by Week)',
                name:           'Day (of week)',
                xDataHint:      'day-of-week',
                replaceLegend:  false
            },
            'w:H':  {
                group:          'Series (by Week)',
                name:           'Hour',
                xDataHint:      'hour',
                replaceLegend:  false
            },

            // Series Timelines (by Day-of-Month)
            'D:H':  {
                group:          'Series (by Day-of-Month)',
                name:           'Hour',
                xDataHint:      'hour',
                replaceLegend:  false
            },

            // Series Timelines (by Day-of-Week)
            'd:H':  {
                group:          'Series (by Day-of-Week)',
                name:           'Hour',
                xDataHint:      'hour',
                xLegendHint:    'day-of-week',
                replaceLegend:  false
            }
        }
    },

    /************************
     * Private methods
     *
     */
    _init: function() {
        var self        = this;
        var opts        = self.options;

        /********************************
         * Initialize jsonRpc
         *
         */
        if ( $.isFunction($.registry) )
        {
            if (opts.jsonRpc === null)
            {
                var api = $.registry('api');
                if (api && api.jsonRpc)
                {
                    opts.jsonRpc = $.extend({}, api.jsonRpc, opts.jsonRpc);
                }
            }
        }

        /********************************
         * Remember initial position
         * settings and add appropriate
         * CSS classes.
         *
         */
        self.element.data('orig-position', self.element.css('position'));
        self.element.css('position', 'relative')
                    .addClass('ui-timeline');

        if ( opts.hideLegend !== true )
        {
            self.element.addClass('ui-timeline-labeled');
        }

        if ($.type(opts.css) === 'string')
        {
            self.element.addClass( opts.css );
        }


        /********************************
         * Locate/create our primary
         * pieces.
         *
         */
        self.$controls = self.element.find('.timeline-controls');
        if ((self.$controls.length < 1) && (opts.createControls === true))
        {
            // Create controls based upon 'opts.grouping'
            self.$controls = self._createControls();
        }
        self.$grouping = self.$controls
                                .find(':input[name="timeline.grouping"]')
                                .input();

        self.$timeline = self.element.find('.timeline-plot');
        if (self.$timeline.length < 1)
        {
            // Append a plot container
            self.$timeline = $('<div class="timeline-plot"></div>');
            self.$timeline.data('remove-on-destroy', true);
            self.element.append(self.$timeline);
        }

        self.$legend = self.element.find('.timeline-legend');
        if ( (self.$legend.length < 1) && (opts.hideLegend !== true) )
        {
            // Append a legend container
            self.$legend = $('<div class="timeline-legend"></div>');

            self.$legend.data('remove-on-destroy', true);
            self.element.append(self.$legend);
        }
        else if ( opts.hideLegend === true )
        {
            self.$legend.hide();
        }


        if (opts.annotation)
        {
            self.$annotation = self.element.find('.timeline-annotation');
            if (self.$annotation.length < 1)
            {
                // Append a annotation container
                self.$annotation = $('<div class="timeline-annotation"></div>');

                self.$annotation.data('remove-on-destroy', true);
                self.element.append(self.$annotation);
            }

            self.$annotation.html(opts.annotation);
        }

        self.hlTimer = null;

        // Ensure that our plot area has a non-zero height OR width
        var width   = self.$timeline.width();
        var height  = self.$timeline.height();

        if (opts.width !== null)
        {
            self.$timeline.css('width', opts.width);
            width = self.$timeline.width();

            if (height <= 10)
            {
                height = width * opts.hwRatio;
                self.$timeline.css('height', height);
            }
        }
        if (opts.height !== null)
        {
            // Measure the timeline height given a parent height.
            self.$timeline.css('height', '100%');
            self.element.css('height', opts.height);
            height = self.$timeline.height();

            // Reset the parent and the timeline heights based upon
            // measurements
            self.element.css('height', 'auto');
            self.$timeline.height( height );

            if (width <= 10)
            {
                width = height / opts.hwRatio;
                self.$timeline.width( width );
            }
        }

        if (width <= 10)
        {
            // Force to the width of the container
            self.$timeline.width( self.element.width() );
            width = self.$timeline.width();
        }

        if (height <= 10)
        {
            // Force the height to a ratio of the width
            height = width * opts.hwRatio;
            self.$timeline.height( height );
        }

        // Interaction events
        self._bindEvents();


        window.setTimeout(function() { self._createPlot(); }, 50);
    },

    _bindEvents: function() {
        var self        = this;
        var opts        = self.options;

        // Handle 'plothover' events
        self.$timeline.bind('plothover', function(e, pos, item) {
            if (! self.hlTimer)
            {
                self.hlTimer = window.setTimeout(function() {
                                                    self._updateHighlights(pos);
                                                 }, 50);
            }
        });

        self.$controls.delegate('input,select', 'change', function(e) {
            self._reload( self.$grouping.val() );
        });
    },

    /** @brief  Create timeline controls based upon this.options.grouping.
     *
     *  @return The jQuery DOM element representing the new controls.
     */
    _createControls: function() {
        var self        = this;
        var opts        = self.options;
        var $controls   = $('<div />').addClass('timeline-controls');
        var $select     = $('<select name="timeline.grouping" />')
                                .appendTo($controls);
        var $group      = null;
        var lastGroup   = null;
        var curGroup    = (opts.rpcParams !== null
                                ? opts.rpcParams.grouping
                                : null);

        $.each(opts.grouping, function(key, info) {
            if (lastGroup !== info.group)
            {
                $group = $('<optgroup label="'+ info.group +'" />')
                            .appendTo($select);
                lastGroup = info.group;
            }
            if ((curGroup === null) || (curGroup === key))
            {
                curGroup = key;
            }

            $group.append(  '<option value="'+ key +'"'
                          +     (curGroup === key ? ' selected' : '') +'>'
                          +  info.name
                          + '</option>');
        });

        $controls.appendTo(self.element);

        return $controls;
    },

    /** @brief  Asynchronously (re)load the data for the presented timeline.
     *  @param  grouping    The new grouping value;
     *
     *  Use this.options:
     *      jsonRpc     the primary Json-RPC information;
     *      rpcMethod   the Json-RPC method;
     *      rpcParams   additional Json-RPC method parameters;
     */
    _reload: function(grouping) {
        var self    = this;
        var opts    = self.options;
        var params  = opts.rpcParams;

        params.grouping = grouping;
        if (opts.maxCount > 0)
        {
            params.count = opts.maxCount;
        }

        // What's the xDataHint based upon 'grouping'?
        var info    = opts.grouping[ grouping ];
        if (info !== undefined)
        {
            opts.xDataHint     = info.xDataHint;
            opts.replaceLegend = (info.replaceLegend === true
                                    ? true
                                    : false);
            if (info.xLegendHint !== undefined)
            {
                opts.xLegendHint = info.xLegendHint;
            }

            if (info.rpcParams !== undefined)
            {
                params = $.extend(params, info.rpcParams);
            }
        }

        self.element.mask();
        $.jsonRpc(opts.jsonRpc, opts.rpcMethod, params, {
            success: function(data) {
                if ( (! data) || (data.error !== null) )
                {
                    $.notify({
                        title:  'Timeline Update failed',
                        text:   '<p class="error">'
                              +  (data ? data.error.message : '')
                              + '</p>'
                    });
                    return;
                }

                opts.data = self._convertData(data.result);
                self._draw();
            },
            error: function(req, textStatus, err) {
                $.notify({
                    title:  'Timeline Update failed',
                    text:   '<p class="error">'
                          +  textStatus
                          + '</p>'
                });
            },
            complete: function(req, textStatus) {
                self.element.unmask();
            }
        });

    },

    /** @brief  Use this.options to generate/update the current timeline.
     *  
     *  Use this.options:
     *      rpcParams.grouping  to determine how to format the ticks and legend;
     *      data                the (converted) plot data;
     */
    _draw: function() {
        var self    = this;
        var opts    = self.options;

        self.$plot  = $.plot(self.$timeline, opts.data, self.flotOpts);

        // Cache the size of the plot box/area
        self.plotBox        = self.$plot.getPlotOffset();
        self.plotBox.width  = self.$plot.width();
        self.plotBox.height = self.$plot.height();
        self.plotBox.right  = self.plotBox.left + self.plotBox.width;
        self.plotBox.bottom = self.plotBox.top  + self.plotBox.height;

        /*
        // Position the legend to the right of the plot box/area
        self.$legend.css({
            position:   'absolute',
            top:        self.plotBox.top   - 5,
            left:       self.plotBox.right + 10
        });
        // */
        self.$legends = self.$legend.find('.legendLabel');

        // Wrap the current content of each legend item in 'timeline-text'
        self.$legends.each(function() {
            var $legend = $(this);

            if ($legend.find('.timeline-text').length < 1)
            {
                $legend.html(  '<span class="timeline-text">'
                             +   $legend.html()
                             + '</span>');
            }
        });
    },

    _createPlot: function() {
        var self            = this;
        var opts            = self.options;
        var flotDefaults    = {
            grid:       { hoverable:true, autoHighlight:false },
            points:     { show:true },
            lines:      { show:true },
            legend:     { container: self.$legend },
            xaxis:      {
                tickFormatter: function(val,data) {
                    return self._xTickFormatter(val, data);
                }
            }
        };

        // Default flot options
        self.flotOpts   = $.extend(true, {}, flotDefaults, opts.flot);

        if (opts.rpcParams !== null)
        {
            var info    = opts.grouping[ opts.rpcParams.grouping ];

            if (info !== undefined)
            {
                opts.xDataHint = info.xDataHint;
                opts.xDataHint     = info.xDataHint;
                opts.replaceLegend = (info.replaceLegend === true
                                        ? true
                                        : false);
                if (info.xLegendHint !== undefined)
                {
                    opts.xLegendHint = info.xLegendHint;
                }
            }
        }

        // Convert any raw data
        if ( $.isArray(opts.rawData) || $.isPlainObject(opts.rawData) )
        {
            opts.data   = self._convertData(opts.rawData);
        }

        self._draw();
    },

    /** @brief  Convert incoming, raw, connexions timeline data into a form
     *          usable by flot.
     *  @param  rawData The raw, connexions timeline data to convert.
     *
     *  @return An array of data series suitable for flot.
     */
    _convertData: function(rawData) {
        var self    = this;
        var opts    = self.options;
        var data    = [];

        opts.xDataType = undefined;
        opts.xDateFmt  = undefined;

        $.each(rawData, function(key, vals) {
            var info    = { label: self._hintFormatter(key, opts.xLegendHint),
                            data:  [] };

            $.each(vals, function(x, y) {
                y = (numericRe.test(y) ? parseInt(y, 10) : y);

                var match   = dateRe.exec(x);
                if (match !== null)
                {
                    match[2] = (match[2] === undefined ? 0 : match[2] - 1);
                    match[3] = (match[3] === undefined ? 1 : match[3]);
                    match[4] = (match[4] === undefined ? 0 : match[4]);
                    match[5] = (match[5] === undefined ? 0 : match[5]);
                    match[6] = (match[6] === undefined ? 0 : match[6]);

                    var newX    = new Date(match[1], match[2], match[3],
                                           match[4], match[5], match[6]);

                    info.data.push([newX, y]);

                    opts.xDataType     = 'date';
                    if (($.type(opts.xDataHint) === 'string') &&
                        (opts.xDataHint.substr(0,4) === 'fmt:'))
                    {
                        opts.xDateFmt  = opts.xDataHint.substr(4);
                        opts.xDataHint = 'fmt';
                    }
                }
                else
                {
                    x = (numericRe.test( x )
                            ? parseInt(x, 10)
                            : x);
                    info.data[x] = [x, y];
                }
            });

            data.push(info);
        });

        return data;
    },

    /** @brief  Given a Date instance and format string, generate a string
     *          representation of the Date.
     *  @param  date    The Date instance;
     *  @param  fmt     The format string;
     *                      %Y  - Year              ( 2010 )
     *                      %m  - Month             ( 01 - 12 )
     *                      %d  - Day               ( 01 - 31 )
     *                      %w  - Day-of-week       ( 0  -  6 )
     *                      %H  - Hour              ( 00 - 23 )
     *                      %M  - Minute            ( 00 - 59 )
     *                      %S  - Second            ( 00 - 59 )
     *                      %z  - Timezone Offset
     *
     *                      %B  - Month Name        ( January - December )
     *                      %b  - Month Name        ( Jan     - Dec      )
     *                      
     *                      %A  - Day-of-week Name  ( Sunday  - Saturday )
     *                      %a  - Day-of-week Name  ( Su      - Sa       )
     *
     *                      %h  - Hour Name         ( 12a     - 11p      )
     *
     *  @return A string representation of the Date.
     */
    _formatDate: function(date, fmt) {
        var self    = this;
        var opts    = self.options;
        var isFmt   = false;
        var res     = [];
        var str;
        for (var idex = 0; idex < fmt.length; idex++)
        {
            var fmtChar = fmt.charAt(idex);
            if (isFmt)
            {
                isFmt = false;
                switch (fmtChar)
                {
                case 'Y':   // Year
                    str = date.getFullYear();
                    break;
    
                case 'm':   // Month (01-12)
                    str = leftPad(date.getMonth() + 1);
                    break;

                case 'd':   // Day   (01-31)
                    str = leftPad(date.getDate());
                    break;

                case 'w':   // Day-of-week (0 - 6)
                    str = date.getDay();
                    break;

                case 'H':   // Hours (00-23)
                    str = leftPad(date.getHours());
                    break;

                case 'M':   // Minutes (00-59)
                    str = leftPad(date.getMinutes());
                    break;

                case 'S':   // Seconds (00-59)
                    str = leftPad(date.getSeconds());
                    break;

                case 'z':   // Timezone offset
                    str = date.getTimezoneOffset();
                    break;

                // Number to String mappings
                case 'B':   // Month (January - December)
                    str = opts.months[date.getMonth()];
                    break;
    
                case 'b':   // Month (Jan - Dec)
                    str = opts.months[date.getMonth()].substr(0,3);
                    break;
    
                case 'A':   // Day-of-week   (Sunday - Saturday)
                    str = opts.days[date.getDay()];
                    break;

                case 'a':   // Day-of-week   (Su - Sa)
                    str = opts.days[date.getDay()].substr(0,2);
                    break;

                case 'h':   // Hours (12a-11p)
                    str = leftPad(opts.hours[date.getHours()], '&nbsp;', 3);
                    break;

                default:
                    str = fmtChar;
                    break;
                }

                res.push(str);
            }
            else if (fmtChar === '%')
            {
                isFmt = true;
            }
            else
            {
                res.push(fmtChar);
            }
        }
    
        return res.join('');
    },

    /** @brief  Given a value, hint, and possibly dateFmt, format the value.
     *  @param  val     The value to format;
     *  @param  hint    The formatting hint (hour | day-of-week |
     *                                       day | week | month | year
     *                                       fmt -- requires 'dateFmt' and
     *                                              also implies that the value
     *                                              is (now) a Date instance);
     *  @param  dateFmt The date format string (iff 'hint' === 'fmt');
     *
     *  @return The formatted string.
     */
    _hintFormatter: function(val, hint, dateFmt) {
        if (! hint)
        {
            return val;
        }

        var self        = this;
        var opts        = self.options;

        switch (hint)
        {
        case 'hour':
            if (val instanceof Date)
            {
                val = val.getHours();
            }
            val = leftPad(opts.hours[ val ], '&nbsp;', 3);
            break;

        case 'day-of-week':
            if (val instanceof Date)
            {
                val = val.getDay();
            }
            val = opts.days[ val ];
            break;

        case 'month':
        case 'mon':
            if (val instanceof Date)
            {
                val = val.getMonth() + 1;
            }
            val = opts.months[ (val > 0 ? val - 1 : val) ];

            if ((hint === 'mon') && (val !== undefined))
            {
                val = val.substr(0,3);
            }
            break;

        case 'day':
            if (val instanceof Date)
            {
                val = val.getDate();
            }
            val = leftPad(val);
            break;

        case 'year':
            if (val instanceof Date)
            {
                val = val.getFullYear();
            }
            break;

        case 'fmt':
            if (val instanceof Date)
            {
                val = self._formatDate(val, dateFmt);
            }
            break;

        // No special formatting
        case 'week':
        }

        return (val === undefined ? '' : val);
    },

    _xTickFormatter: function(val, data) {
        var self        = this;
        var opts        = self.options;

        if (opts.xDataType === 'date')
        {
            val = new Date( val );
        }
        
        return self._hintFormatter(val, opts.xDataHint, opts.xDateFmt);
    },

    /** @brief  Present a "tip" for the given series and point
     *  @param  idex    The series index;
     *  @param  series  The series
     *  @param  p       The point
     */
    _showTip:   function(idex, series, p) {
        if (p === null)
        {
            return;
        }

        var self        = this;
        var opts        = self.options;
        var hlRadius    = (series.points.radius + series.points.lineWidth);
        var itemPos     = {
            top:    series.yaxis.p2c(p[1]),
            left:   series.xaxis.p2c(p[0])
        };
        //var x           = series.xaxis.tickFormatter(p[0], series.xaxis);
        var y           = series.yaxis.tickFormatter(p[1], series.yaxis);
        var str         = y;    //x +': '+ y;

        var tip         = '<div class="timeline-tooltip">'
                        +  str
                        + '</div>';
        var yaxis       = series.yaxis;
        var $tip        = $(tip).css({
                            position:           'absolute',
                            top:                itemPos.top  - hlRadius - 5,
                            left:               itemPos.left + (hlRadius*2)
                                                             + 5,
                            'text-align':       'left',
                            /*
                            'font-size':        yaxis.font.size +'px',
                            'font-family':      yaxis.font.family,
                            'font-weight':      yaxis.font.weight,
                            */
                            width:              yaxis.labelWidth +'px',
                            height:             yaxis.labelHeight +'px',
                            color:              series.yaxis.options.color
                        });
        self.$timeline.append($tip);

        /* Adjust the position of the tip to be within the bounds of the
         * plot
         */
        var tipBox      = $tip.position();
        tipBox.width    = $tip.outerWidth();
        tipBox.height   = $tip.outerHeight();
        tipBox.left    += tipBox.width;
        tipBox.right    = tipBox.left + tipBox.width;
        tipBox.bottom   = tipBox.top  + tipBox.height;

        if (tipBox.top    < self.plotBox.top)
        {
            tipBox.top = itemPos.top + hlRadius + hlRadius + 5;
        }
        else if (tipBox.bottom > self.plotBox.bottom)
        {
            tipBox.top = self.plotBox.bottom - tipBox.height - 5;
        }

        if (tipBox.left   < self.plotBox.left)
        {
            tipBox.left = self.plotBox.left + 5;
        }
        else if (tipBox.right > self.plotBox.right)
        {
            tipBox.left = self.plotBox.right - tipBox.width - 10;
        }

        $tip.css({
            top:    tipBox.top,
            left:   tipBox.left
        });
    },

    /** @brief  Update the legend to include the current y value for the
     *          specified series.
     *  @param  idex    The series index;
     *  @param  series  The series;
     *  @param  p       The point;
     */
    _updateLegend: function(idex, series, p) {
        if (p === null)
        {
            return;
        }

        var self    = this;
        var opts    = self.options;
        var $legend = self.$legends.eq(idex);
        var $stat   = $legend.find('.timeline-stat');
        var x       = series.xaxis.tickFormatter(p[0], series.xaxis);
        var y       = series.yaxis.tickFormatter(p[1], series.yaxis);
        var str     = (opts.replaceLegend ? '' : ': ') + x +': '+ y;

        if ($stat.length > 0)
        {
            $stat.html( str )
                 .show();
        }
        else
        {
            var html    = '<span class="timeline-stat">'
                        +  str
                        + '</span>';

            $legend.append(  html );

        }

        if (opts.replaceLegend)
        {
            $legend.find('.timeline-text').hide();
        }
    },

    /** @brief  Update the highlighted points based upon the reported mouse
     *          position.
     *  @param  pos     The reported mouse position;
     */
    _updateHighlights: function(pos) {
        var self    = this;
        var opts    = self.options;

        // Clear all highlights, tips, and label stats and tips
        self.$plot.unhighlight();
        self.$timeline.find('.timeline-tooltip').remove();
        self.$legends
                .find('.timeline-stat').hide()
                .end()
                .find('.timeline-text').show();

        var axes    = self.$plot.getAxes();
        if ( (pos.x < axes.xaxis.min) || (pos.x > axes.xaxis.max) ||
             (pos.y < axes.yaxis.min) || (pos.y > axes.yaxis.max) )
        {
            self.hlTimer = null;
            return;
        }

        var idex, jdex, dataset = self.$plot.getData();
        for (idex = 0; idex < dataset.length; idex++)
        {
            var series  = dataset[idex];
            var p       = null;
            var p1      = null;
            var p2      = null;

            // Locate the items on either side of the mouse's x position
            for (jdex = 0; jdex < series.data.length; jdex++)
            {
                if (series.data[jdex] === undefined)
                {
                    continue;
                }

                var pt  = series.data[jdex];
                if ( pt[0] > pos.x )
                {
                    if ((p2 === null) || (pt[0] < p2[0]))
                    {
                        p2 = pt;
                    }
                }
                else if ( pt[0] < pos.x )
                {
                    if ((p1 === null) || (pt[0] > p1[0]))
                    {
                        p1  = pt;
                    }
                }
            }

            // Choose the closest point
            if (p1 === null)
            {
                p = p2;
            }
            else if (p2 === null)
            {
                p = p1;
            }
            else
            {
                if (Math.abs(pos.x - p1[0]) < Math.abs(pos.x - p2[0]))
                {
                    p = p1;
                }
                else
                {
                    p = p2;
                }
            }

            // Highlight the point
            self.$plot.highlight(series, p, false);

            // Present point information in legend and/or tips
            if (opts.valueInLegend)
            {
                self._updateLegend(idex, series, p);
            }
            if (opts.valueInTips)
            {
                self._showTip(idex, series, p);
            }
        }

        self.hlTimer = null;
    },

    /************************
     * Public methods
     *
     */
    destroy: function() {
        var self        = this;
        var opts        = self.options;

        // Remove added items
        self.$plot.shutdown();
        self.$timeline.find('.timeline-tooltip').remove();

        if (self.$annotation.data('remove-on-destroy') === true)
        {
            self.$annotation.remove();
        }

        if (self.$legend.data('remove-on-destroy') === true)
        {
            self.$legend.remove();
        }
        else
        {
            // Unwrap the legend text
            self.$legends.each(function() {
                var $legend = $(this);

                $legend.html(  $legend.find('.timeline-text').html() );
            });
        }

        if (self.$timeline.data('remove-on-destroy') === true)
        {
            self.$timeline.remove();
        }

        self.element.css('position', self.element.data('orig-position'))
                    .removeData('orig-position')
                    .removeClass('ui-timeline');

        if ( opts.hideLegend !== true )
        {
            self.element.removeClass('ui-timeline-labeled');
        }

        if ($.type(opts.css) === 'string')
        {
            self.element.removeClass( opts.css );
        }
    }
});
    
}(jQuery));
