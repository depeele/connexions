<?php
/** @file
 *
 *  Abstract base class for a Data Access Object to Model mapper.
 *
 */
abstract class Connexions_Model_Mapper
{
    /** @brief  Returned from a factory if no instance can be located or 
     *          generated.
     */
    const       NO_INSTANCE             = -1;

    // A cache of Data Accessor instances, by class name
    static protected    $_instCache     = array();

    /** @brief  An identity map holding Domain Model instances generated by
     *          this mapper.
     */
    protected           $_identityMap   = array();


    /* Data Accessor (e.g. Table Data Gateway / Zend_Db_Table_Abstract) for
     * this mapper.
     */
    protected           $_accessor      = null;

    // The name of the Model Set class to use when retrieving multiple items.
    protected           $_modelSetName  = null;

    /** @brief  Create a new mapper.
     *  @param  config  Configuration:
     *                      accessor        The name of a Data Accessor class,
     *                                      or the Data Accessor Object
     *                                      instance to use
     *                                      (e.g.  Model_Mapper_*)
     *                      modelSetName    The name of the Data Set class to
     *                                      use when retrieving multiple items
     *                                      (by default, this will be
     *                                       constructed from the name of the
     *                                       concrete class of this Mapper).
     */
    public function __construct($config = array())
    {
        $config = (array)$config;

        foreach ($config as $key => $val)
        {
            $method = 'set'. ucfirst($key);
            if (! method_exists( $this, $method ))
            {
                throw new Exception(get_class($this)
                                    . ": Unknown property '{$key}'");
            }

            $this->{$method}($val);
        }

        // Register this instance with the factory
        self::factory($this);
    }

    /** @brief  Set the current Data Access Object instance.
     *  @param  accessor    The new Data Access Object instance.
     *
     *  Note: If a concrete sub-class is able to establish a default accessor,
     *        it should do so in this method when the incoming accessor is null.
     *
     *  @return $this for a fluent interface.
     */
    public function setAccessor($accessor)
    {
        $this->_accessor = self::accessorFactory($accessor);

        return $this;
    }

    /** @brief  Get the current Data Access Object instance.
     *  @param  name    The name of the specific Accessor to retrieve.
     *
     *  @return The current Data Access Object instance.
     */
    public function getAccessor($name = null)
    {
        if ($name !== null)
        {
            // Retrieve a specific Accessor (by class name).
            return self::accessorFactory($name);
        }

        if ( (! is_object($this->_accessor)) &&
             ($this->_accessor !== self::NO_INSTANCE) )
        {
            /* No accessor has been set.  Rely on any concrete sub-class to
             * identify a default accessor and return it.
             */
            $this->setAccessor($this->_accessor);
        }

        if (! is_object($this->_accessor))
        {
            throw new Exception("Connexions_Model_Mapper::getAccessor: "
                                . "No accessor located for this mapper "
                                . '( '. get_class($this) .' )');
        }

        return $this->_accessor;
    }

    /** @brief  Set the name of the Model Set class to use when retrieving
     *          multiple items.
     *  @param  modelSetName    The name of the Model Set.
     *
     *  @return $this for a fluent interface.
     */
    public function setModelSetName($modelSetName = null)
    {
        if ($modelSetName === null)
        {
            /* Use the name of the current class to construct a Model Set
             * class name:
             *      Model_Mapper_<Class> => Model_Set_<Class>
             */
            $modelSetName = str_replace('Model_Mapper_', 'Model_Set_',
                                        get_class($this));

            /*
            Connexions::log("Connexions_Model_Mapper::setModelSetName(%s)",
                            $modelSetName);
            // */
        }

        $this->_modelSetName = $modelSetName;

        return $this;
    }

    /** @brief  Get the name of the Model Set class for this mapper.
     *
     *  @return The name of the Model Set class.
     */
    public function getModelSetName()
    {
        if ($this->_modelSetName === null)
        {
            /* No name has been set.  Invoke 'setModelSetName()' to construct
             * the name from the name of the class of this instance.
             */
            $this->setModelSetName();
        }

        return $this->_modelSetName;
    }

    /** @brief  Convert the incoming model into an array containing only 
     *          data that should be directly persisted.  This method may also
     *          be used to update dynamic values
     *          (e.g. update date/time, last visit date/time).
     *  @param  model   The Domain Model to reduce to an array.
     *
     *  @return A filtered associative array containing data that should 
     *          be directly persisted.
     */
    public function reduceModel(Connexions_Model $model)
    {
        return $model->toArray( Connexions_Model::DEPTH_SHALLOW,
                                Connexions_Model::FIELDS_ALL );
                                //Connexions_Model::FIELDS_PUBLIC );
    }

    /** @brief  Create a new instance of the Domain Model given raw data.
     *  @param  data    The raw data.
     *
     *  @return The matching Domain Model (null if no match).
     */
    public function makeModel($data)
    {
        /*
        Connexions::log("Connexions_Model_Mapper::makeModel: %s",
                        (is_object($data)
                            ? get_class($data)
                            : gettype($data)) );
        // */
                        
        $modelName   = $this->getModelName();
        $domainModel = new $modelName(array('mapper'    => $this,
                                            'isBacked'  => true,
                                            'isValid'   => true,
                                            'data'      => $data));

        return $domainModel;
    }

    /** @brief  Remove the given model instance from the identity map.
     *  @param  model   The model instance.
     *
     *  @return $this for a fluent interface.
     */
    public function unsetIdentity(Connexions_Model $model)
    {
        $this->_unsetIdentity($model->getId(), $model);

        return $this;
    }

    /*********************************************************************
     * Abstract methods
     *
     */

    /** @brief  Save the given model instance.
     *  @param  model   The model instance to save.
     *
     *  Note: This should invoke reduceModel() on Model Data before it is
     *        persisted.
     *
     *  @return The updated model instance.
     */
    abstract public function save(Connexions_Model $model);

    /** @brief  Delete the data for the given model instance.
     *  @param  model   The model instance to delete.
     *
     *  @return $this for a fluent interface.
     */
    abstract public function delete(Connexions_Model $model);

    /** @brief  Retrieve the model instance with the given id.
     *  @param  id      The model instance identifier.
     *
     *  @return The matching model instance (null if no match).
     */
    abstract public function find($id);

    /** @brief  Fetch all matching model instances.
     *  @param  where   Optional WHERE clause (string, array, Zend_Db_Select)
     *  @param  order   Optional ORDER clause (string, array)
     *  @param  count   Optional LIMIT count
     *  @param  offset  Optional LIMIT offset
     *
     *  @return A Connexions_Model_Set instance that provides access to all
     *          matching Domain Model instances.
     */
    abstract public function fetch($where   = null,
                                   $order   = null,
                                   $count   = null,
                                   $offset  = null);

    /** @brief  Fetch all matching model instances by a specific field.
     *  @param  field   The field to match on;
     *  @param  value   A single value or array of values to match;
     *  @param  order   Optional ORDER clause (string, array)
     *  @param  count   Optional LIMIT count
     *  @param  offset  Optional LIMIT offset
     *
     *  @return A Connexions_Model_Set instance that provides access to all
     *          matching Domain Model instances.
     */
    abstract public function fetchBy($field,
                                     $value,
                                     $order   = null,
                                     $count   = null,
                                     $offset  = null);

    /*********************************************************************
     * Protected methods
     *
     */

    /** @brief  See if we have a model instance for the given 'id'
     *  @param  id      The model instance identifier.
     *
     *  @return true | false
     */
    protected function _hasIdentity($id)
    {
        if (is_array($id))
            $id = implode(':', array_values($id));

        return array_key_exists($id, $this->_identityMap);
    }

    /** @brief  See if we've already instantiated a model instance for the
     *          given 'id'
     *  @param  id      The model instance identifier.
     *
     *  @return The Model instance (null if not found).
     */
    protected function _getIdentity($id)
    {
        if (is_array($id))
            $id = implode(':', array_values($id));

        if (array_key_exists($id, $this->_identityMap))
        {
            /*
            Connexions::log("Connexions_Model_Mapper::_getIdentity( %s ): %s: "
                            .   "return identity instance",
                             $id, get_class($this));
            // */

            return $this->_identityMap[$id];
        }

        return null;
    }

    /** @brief  Save a new Model instance in our identity map.
     *  @param  id      The model instance identifier.
     *  $param  model   The model instance.
     *
     *  @return The Model instance (null if not found).
     */
    protected function _setIdentity($id, Connexions_Model $model)
    {
        if (is_array($id))
            $id = implode(':', array_values($id));

        /*
        if ($this->_hasIdentity($id))
        {
            Connexions::log("Connexions_Model_Mapper::_setIdentity( %s ): %s: "
                            .   "replacing existing instance",
                             $id, get_class($this));
        }
        // */

        Connexions::log("Connexions_Model_Mapper::_setIdentity( %s ): %s",
                         $id, get_class($this));

        $this->_identityMap[$id] = $model;
    }

    /** @brief  Remove an identity map entry.
     *  @param  id      The model instance identifier.
     *  $param  model   The model instance currently mapped.
     */
    protected function _unsetIdentity($id, Connexions_Model $model)
    {
        if (is_array($id))
            $id = implode(':', array_values($id));

        /*
        Connexions::log("Connexions_Model_Mapper::_unsetIdentity( %s ): %s",
                        $id, get_class($this));
        // */

        unset($this->_identityMap[$id]);
    }

    /*********************************************************************
     * Static methods
     *
     */

    /** @brief  Given a Mapper Class name, retrieve the associated Mapper 
     *          instance.
     *  @param  mapper The Mapper Class name or instance.
     *
     *  @return The Model_Mapper instance.
     */
    public static function factory($mapper)
    {
        if ($mapper instanceof Connexions_Model_Mapper)
        {
            $mapperName = get_class($mapper);
        }
        else
        {
            // See if we have a Mapper instance with this name in our cache
            $mapperName = $mapper;
            if ( isset(self::$_instCache[ $mapperName ]))
            {
                // YES - use the existing instance
                $mapper =& self::$_instCache[ $mapperName ];
            }
            else
            {
                // NO - create a new instance
                try
                {
                    @Zend_Loader_Autoloader::autoload($mapperName);
                    $mapper  = new $mapperName();
                }
                catch (Exception $e)
                {
                    // Simply return null
                    $mapper = self::NO_INSTANCE;

                    // /*
                    Connexions::log("Connexions_Model_Mapper::factory: "
                                    . "CANNOT locate class '%s'",
                                    $mapperName);
                    // */
                }
            }
        }

        if (! isset(self::$_instCache[ $mapperName ]))
        {
            self::$_instCache[ $mapperName ] = $mapper;

            /*
            Connexions::log("Connexions_Model_Mapper::factory( %s ): "
                            . "cache this Mapper instance",
                            $mapperName);
            // */
        }

        return $mapper;
    }

    /** @brief  Given a Data Accessor Class name, retrieve the associated
     *          Accessor instance.
     *  @param  accessor    The Data Accessor Class name or instance.
     *
     *  @return The Model_Mapper_* instance.
     */
    public static function accessorFactory($accessor)
    {
        if ( is_object($accessor) )
        {
            $accessorName = get_class($accessor);
        }
        else
        {
            // See if we have a Accessor instance with this name in our cache
            $accessorName = $accessor;
            if ( isset(self::$_instCache[ $accessorName ]))
            {
                // YES - use the existing instance
                $accessor =& self::$_instCache[ $accessorName ];
            }
            else
            {
                // NO - create a new instance
                try
                {
                    @Zend_Loader_Autoloader::autoload($accessorName);
                    $accessor  = new $accessorName();
                }
                catch (Exception $e)
                {
                    // Simply return null
                    $accessor = self::NO_INSTANCE;

                    // /*
                    Connexions::log("Connexions_Model_Mapper::accessorFactory: "
                                    . "CANNOT locate class '%s'",
                                    $accessorName);
                    // */
                }
            }
        }

        if (! isset(self::$_instCache[ $accessorName ]))
        {
            self::$_instCache[ $accessorName ] = $accessor;

            /*
            Connexions::log("Connexions_Model::accessorFactory( %s ): "
                            . "cache this Accessor instance ( %s )",
                            $accessorName,
                            (is_object($accessor)
                                ? 'class: '. get_class($accessor)
                                : $accessor));
            // */
        }

        return $accessor;
    }
}
